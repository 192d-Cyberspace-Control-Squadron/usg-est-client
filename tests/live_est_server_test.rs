// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 U.S. Federal Government (in countries where recognized)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Live integration tests against testrfc7030.com EST test server
//!
//! These tests are marked with `#[ignore]` by default because they require
//! network access to the public EST test server at testrfc7030.com.
//!
//! To run these tests:
//! ```bash
//! cargo test --test live_est_server_test --all-features -- --ignored
//! ```
//!
//! ## Test Server Information
//!
//! The testrfc7030.com server provides three EST instances:
//!
//! - **Port 443**: TLS channel binding enabled (RFC 7030 §3.5)
//! - **Port 8443**: TLS channel binding disabled (curl-compatible) ← Used by these tests
//! - **Port 9443**: No HTTP auth, requires client certificate
//!
//! ### Test Configuration
//!
//! - **URL**: https://testrfc7030.com:8443
//! - **Credentials**: estuser / estpwd
//! - **CA Certificate**: tests/fixtures/certs/testrfc7030-ca.pem
//!
//! See: http://testrfc7030.com/ for more details
//!
//! **Note**: Certificates generated by this test server are for demonstration
//! purposes only and should not be used for production.
//!
//! **Note**: The test server may be temporarily unavailable. Tests will skip
//! gracefully if the server is unreachable.

use std::fs;
use usg_est_client::{EnrollmentResponse, EstClient, EstClientConfig, EstError};

/// EST test server URLs
const TEST_SERVER_URL_TLS_CHANNEL_ENABLED: &str = "https://testrfc7030.com:443";
const TEST_SERVER_URL_TLS_CHANNEL_DISABLED: &str = "https://testrfc7030.com:8443";
const TEST_SERVER_URL_TLS_CERT_AUTH: &str = "https://testrfc7030.com:9443";

/// Test credentials
const TEST_USERNAME: &str = "estuser";
const TEST_PASSWORD: &str = "estpwd";

/// Path to the test server's CA certificate
const CA_CERT_PATH: &str = "tests/fixtures/certs/testrfc7030-ca.pem";

/// Helper to load the CA certificate as PEM bytes
fn load_ca_cert() -> Vec<u8> {
    fs::read(CA_CERT_PATH).expect(
        "Failed to read CA certificate - ensure tests/fixtures/certs/testrfc7030-ca.pem exists",
    )
}

/// Check if an error indicates the server is unreachable
fn is_connection_error(err: &EstError) -> bool {
    match err {
        EstError::Http(e) => {
            let msg = format!("{:?}", e);
            msg.contains("Connection refused")
                || msg.contains("ConnectError")
                || msg.contains("timeout")
                || msg.contains("No route to host")
        }
        _ => false,
    }
}

/// Skip test if server is unreachable
macro_rules! skip_if_unreachable {
    ($result:expr) => {
        match $result {
            Ok(v) => v,
            Err(ref e) if is_connection_error(e) => {
                println!("SKIPPED: Test server unreachable - {:?}", e);
                return;
            }
            Err(e) => panic!("Unexpected error: {:?}", e),
        }
    };
}

/// Helper to create an EST client configured for the test server with authentication
async fn create_test_client() -> Result<EstClient, EstError> {
    let ca_cert_pem = load_ca_cert();

    let config = EstClientConfig::builder()
        .server_url(TEST_SERVER_URL_TLS_CHANNEL_ENABLED)?
        .trust_explicit(vec![ca_cert_pem])
        .http_auth(TEST_USERNAME, TEST_PASSWORD)
        .build()
        .map_err(|e| EstError::config(e))?;

    EstClient::new(config).await
}

/// Helper to create an EST client without authentication (for cacerts)
async fn create_unauthenticated_client() -> Result<EstClient, EstError> {
    let ca_cert_pem = load_ca_cert();

    let config = EstClientConfig::builder()
        .server_url(TEST_SERVER_URL_TLS_CHANNEL_ENABLED)?
        .trust_explicit(vec![ca_cert_pem])
        .build()
        .map_err(|e| EstError::config(e))?;

    EstClient::new(config).await
}

// ============================================================================
// GET /cacerts Tests
// ============================================================================

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_get_cacerts() {
    let client = create_unauthenticated_client()
        .await
        .expect("Failed to create EST client");

    let certs = skip_if_unreachable!(client.get_ca_certs().await);

    assert!(
        !certs.is_empty(),
        "Expected at least one CA certificate from server"
    );

    // Verify we got valid certificates by checking the first one has a subject
    for (i, cert) in certs.iter().enumerate() {
        println!(
            "CA Certificate {}: Subject = {:?}",
            i, cert.tbs_certificate.subject
        );
    }
}

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_cacerts_with_auth() {
    // The /cacerts endpoint should work both with and without authentication
    let client = create_test_client()
        .await
        .expect("Failed to create EST client");

    let certs = skip_if_unreachable!(client.get_ca_certs().await);
    assert!(!certs.is_empty(), "Expected at least one CA certificate");
}

// ============================================================================
// GET /csrattrs Tests
// ============================================================================

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_get_csrattrs() {
    let client = create_unauthenticated_client()
        .await
        .expect("Failed to create EST client");

    let result = client.get_csr_attributes().await;

    // CSR attributes are optional - server may return 404 or empty response
    match result {
        Ok(attrs) => {
            println!("CSR Attributes received: {} OIDs", attrs.oids().len());
            for oid in attrs.oids() {
                println!("  OID: {}", oid);
            }
        }
        Err(EstError::NotSupported { .. }) => {
            println!("Server does not support CSR attributes (404) - this is acceptable");
        }
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable");
        }
        Err(e) => {
            panic!("Unexpected error getting CSR attributes: {:?}", e);
        }
    }
}

// ============================================================================
// POST /simpleenroll Tests
// ============================================================================

#[cfg(feature = "csr-gen")]
#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_simple_enroll() {
    use usg_est_client::csr::CsrBuilder;

    let client = create_test_client()
        .await
        .expect("Failed to create EST client");

    // Generate a CSR for testing
    let (csr_der, _key_pair) = CsrBuilder::new()
        .common_name("EST Test Client")
        .organization("Test Organization")
        .country("US")
        .build()
        .expect("Failed to generate CSR");

    let result = client.simple_enroll(&csr_der).await;

    match result {
        Ok(EnrollmentResponse::Issued { certificate }) => {
            println!(
                "Enrollment successful! Certificate subject: {:?}",
                certificate.tbs_certificate.subject
            );
            println!(
                "Certificate serial: {:?}",
                certificate.tbs_certificate.serial_number
            );
            println!(
                "Certificate validity: {:?} - {:?}",
                certificate.tbs_certificate.validity.not_before,
                certificate.tbs_certificate.validity.not_after
            );
        }
        Ok(EnrollmentResponse::Pending { retry_after }) => {
            println!(
                "Enrollment pending - server requested retry after {} seconds",
                retry_after
            );
            // This is acceptable - some servers queue requests
        }
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable");
        }
        Err(e) => {
            panic!("Enrollment failed with unexpected error: {:?}", e);
        }
    }
}

#[cfg(feature = "csr-gen")]
#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_enroll_without_auth_fails() {
    use usg_est_client::csr::CsrBuilder;

    // Create client without authentication
    let client = create_unauthenticated_client()
        .await
        .expect("Failed to create EST client");

    // Generate a CSR
    let (csr_der, _key_pair) = CsrBuilder::new()
        .common_name("Unauthorized Test")
        .build()
        .expect("Failed to generate CSR");

    let result = client.simple_enroll(&csr_der).await;

    // Should fail with authentication required
    assert!(
        result.is_err(),
        "Enrollment should fail without authentication"
    );

    let err = result.unwrap_err();
    if is_connection_error(&err) {
        println!("SKIPPED: Test server unreachable");
        return;
    }
    match err {
        EstError::AuthenticationRequired { .. } => {
            println!("Correctly received authentication required error");
        }
        EstError::ServerError { status, .. } if status == 401 => {
            println!("Correctly received 401 Unauthorized");
        }
        _ => {
            panic!("Expected authentication error, got: {:?}", err);
        }
    }
}

// ============================================================================
// TLS Configuration Tests
// ============================================================================

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_tls_connection() {
    // Verify TLS works with explicit trust anchor
    let ca_cert_pem = load_ca_cert();

    let config = EstClientConfig::builder()
        .server_url(TEST_SERVER_URL_TLS_CHANNEL_ENABLED)
        .expect("Valid URL")
        .trust_explicit(vec![ca_cert_pem])
        .build()
        .expect("Valid config");

    let client = EstClient::new(config).await;
    assert!(
        client.is_ok(),
        "TLS connection should succeed with correct CA"
    );

    // Verify /cacerts works
    let client = client.unwrap();
    let _certs = skip_if_unreachable!(client.get_ca_certs().await);
    println!("TLS connection successful");
}

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_tls_without_ca_fails() {
    // Without the correct CA certificate, TLS should fail
    let config = EstClientConfig::builder()
        .server_url(TEST_SERVER_URL_TLS_CHANNEL_ENABLED)
        .expect("Valid URL")
        .build()
        .expect("Valid config");

    let client = EstClient::new(config).await;

    // This test expects failure because the test server uses a self-signed cert
    // that won't be in the WebPKI trust store
    if client.is_ok() {
        let client = client.unwrap();
        let result = client.get_ca_certs().await;
        // If client creation succeeded, the actual request should fail
        // (unless server is unreachable, in which case we skip)
        if let Err(ref e) = result {
            if is_connection_error(e) {
                println!("SKIPPED: Test server unreachable");
                return;
            }
        }
        assert!(
            result.is_err(),
            "Request should fail with untrusted certificate"
        );
    }
    // If client creation failed, that's also expected
    println!("TLS correctly failed without proper CA certificate");
}

// ============================================================================
// Error Handling Tests
// ============================================================================

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_invalid_endpoint() {
    let client = create_unauthenticated_client()
        .await
        .expect("Failed to create EST client");

    // Test CSR attributes endpoint - server may or may not support it
    let result = client.get_csr_attributes().await;

    // Server should return either CSR attrs or 404 Not Supported
    match result {
        Ok(_) => println!("CSR attributes returned"),
        Err(EstError::NotSupported { .. }) => {
            println!("Server returned 404 Not Supported - expected behavior")
        }
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable")
        }
        Err(e) => println!("Other error (may be acceptable): {:?}", e),
    }
}

// ============================================================================
// Full Workflow Test
// ============================================================================

#[cfg(feature = "csr-gen")]
#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_full_enrollment_workflow() {
    use usg_est_client::csr::CsrBuilder;

    println!("=== Full EST Enrollment Workflow Test ===\n");

    // Step 1: Get CA certificates (unauthenticated)
    println!("Step 1: Retrieving CA certificates...");
    let client = create_unauthenticated_client()
        .await
        .expect("Failed to create unauthenticated client");

    let ca_certs = match client.get_ca_certs().await {
        Ok(certs) => certs,
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable");
            return;
        }
        Err(e) => panic!("Failed to get CA certs: {:?}", e),
    };
    println!("  ✓ Retrieved {} CA certificate(s)\n", ca_certs.len());

    // Step 2: Get CSR attributes (optional)
    println!("Step 2: Retrieving CSR attributes...");
    match client.get_csr_attributes().await {
        Ok(attrs) => println!("  ✓ Got {} CSR attribute OID(s)\n", attrs.oids().len()),
        Err(EstError::NotSupported { .. }) => {
            println!("  ○ CSR attributes not supported by server (404)\n")
        }
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable");
            return;
        }
        Err(e) => println!("  ! CSR attributes error: {:?}\n", e),
    }

    // Step 3: Enroll with authentication
    println!("Step 3: Enrolling with HTTP Basic authentication...");
    let auth_client = create_test_client()
        .await
        .expect("Failed to create authenticated client");

    let (csr_der, _key_pair) = CsrBuilder::new()
        .common_name("EST Workflow Test")
        .organization("USG EST Client Test Suite")
        .country("US")
        .build()
        .expect("Failed to generate CSR");

    match auth_client.simple_enroll(&csr_der).await {
        Ok(EnrollmentResponse::Issued { certificate }) => {
            println!("  ✓ Enrollment successful!");
            println!("    Subject: {:?}", certificate.tbs_certificate.subject);
            println!(
                "    Serial: {:?}",
                certificate.tbs_certificate.serial_number
            );
            println!(
                "    Valid: {:?} to {:?}",
                certificate.tbs_certificate.validity.not_before,
                certificate.tbs_certificate.validity.not_after
            );
        }
        Ok(EnrollmentResponse::Pending { retry_after }) => {
            println!(
                "  ○ Enrollment pending (retry after {} seconds)",
                retry_after
            );
        }
        Err(ref e) if is_connection_error(e) => {
            println!("SKIPPED: Test server unreachable");
            return;
        }
        Err(e) => {
            panic!("  ✗ Enrollment failed: {:?}", e);
        }
    }

    println!("\n=== Workflow Complete ===");
}

// ============================================================================
// Connection Timeout Test
// ============================================================================

#[tokio::test]
#[ignore = "requires network access to testrfc7030.com"]
async fn test_live_connection_timeout() {
    let ca_cert_pem = load_ca_cert();

    // Configure with a reasonable timeout
    let config = EstClientConfig::builder()
        .server_url(TEST_SERVER_URL_TLS_CHANNEL_ENABLED)
        .expect("Valid URL")
        .trust_explicit(vec![ca_cert_pem])
        .timeout(std::time::Duration::from_secs(30))
        .build()
        .expect("Valid config");

    let client = EstClient::new(config)
        .await
        .expect("Failed to create client");

    // This should complete within the timeout
    let _certs = skip_if_unreachable!(client.get_ca_certs().await);
    println!("Request completed within timeout");
}
